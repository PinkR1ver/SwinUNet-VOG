<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SwinUNet è§†çº¿ä¼°è®¡æ¼”ç¤º</title>
    
    <!-- æœ¬åœ°ä¾èµ–ï¼ˆæ— éœ€ç½‘ç»œï¼Œé¿å… VPN å¹²æ‰°ï¼‰ -->
    <script src="lib/ort.min.js"></script>
    <script src="lib/face_mesh.js"></script>
    <script src="lib/chart.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }
        
        .btn-secondary {
            background: #e0e7ff;
            color: #667eea;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.3s;
            display: inline-block;
        }
        
        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .card h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        #video {
            width: 100%;
            border-radius: 8px;
            background: #000;
        }
        
        #eyeCanvas {
            width: 100%;
            max-width: 300px;
            border-radius: 8px;
            background: #000;
            display: block;
            margin: 0 auto;
        }
        
        .gaze-info {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        
        .info-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .info-box .label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .info-box .value {
            font-size: 1.8em;
            font-weight: bold;
            color: #667eea;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 15px;
        }
        
        .status {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        
        .status.info {
            background: #e0e7ff;
            color: #667eea;
            display: block;
        }
        
        .status.success {
            background: #d1fae5;
            color: #065f46;
            display: block;
        }
        
        .status.error {
            background: #fee2e2;
            color: #991b1b;
            display: block;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
        }
        
        .spinner {
            border: 4px solid #f3f3f0;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .footer {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¯ SwinUNet è§†çº¿ä¼°è®¡æ¼”ç¤º</h1>
            <p>åŸºäºæ·±åº¦å­¦ä¹ çš„å®æ—¶è§†çº¿è¿½è¸ªç³»ç»Ÿ</p>
        </div>
        
        <div class="content">
            <div id="status" class="status info">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>æ­£åœ¨åˆå§‹åŒ–æ¨¡å‹ï¼Œè¯·ç¨å€™...</p>
                </div>
            </div>
            
            <div class="controls">
                <div class="file-input-wrapper">
                    <input type="file" id="videoInput" accept="video/*" disabled>
                    <label for="videoInput" class="file-input-label" id="fileLabel">
                        ğŸ“ é€‰æ‹©è§†é¢‘æ–‡ä»¶
                    </label>
                </div>
                
                <button id="startBtn" class="btn btn-primary" disabled>
                    â–¶ï¸ å¼€å§‹å¤„ç†
                </button>
                <button id="stopBtn" class="btn btn-secondary" disabled>
                    â¹ï¸ åœæ­¢
                </button>
                <select id="eyeSelect" class="btn btn-secondary">
                    <option value="left">å·¦çœ¼</option>
                    <option value="right">å³çœ¼</option>
                </select>
                <button id="clearBtn" class="btn btn-secondary">
                    ğŸ—‘ï¸ æ¸…ç©ºå†å²
                </button>
            </div>
            
            <div class="main-grid">
                <div class="card">
                    <h3>ğŸ“¹ è§†é¢‘è¾“å…¥</h3>
                    <video id="video" controls></video>
                </div>
                
                <div class="card">
                    <h3>ğŸ‘ï¸ çœ¼éƒ¨ ROI</h3>
                    <canvas id="eyeCanvas" width="240" height="144"></canvas>
                </div>
            </div>
            
            <div class="card">
                <h3>ğŸ“Š è§†çº¿æ•°æ®</h3>
                <div class="gaze-info">
                    <div class="info-box">
                        <div class="label">Pitch (ä¿¯ä»°è§’)</div>
                        <div class="value" id="pitchValue">--</div>
                    </div>
                    <div class="info-box">
                        <div class="label">Yaw (åèˆªè§’)</div>
                        <div class="value" id="yawValue">--</div>
                    </div>
                    <div class="info-box">
                        <div class="label">FPS</div>
                        <div class="value" id="fpsValue">--</div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="gazeChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>SwinUNet-VOG Â© 2024 | åŸºäº ONNX Runtime Web å’Œ MediaPipe</p>
        </div>
    </div>
    
    <script>
        let session = null;
        let faceMesh = null;
        let gazeAPI = null;
        let video = null;
        let isRunning = false;
        let chart = null;
        let frameCount = 0;
        let lastTime = Date.now();
        let videoFile = null;
        
        const statusDiv = document.getElementById('status');
        const videoInput = document.getElementById('videoInput');
        const fileLabel = document.getElementById('fileLabel');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const eyeSelect = document.getElementById('eyeSelect');
        const clearBtn = document.getElementById('clearBtn');
        const videoElement = document.getElementById('video');
        const eyeCanvas = document.getElementById('eyeCanvas');
        const eyeCtx = eyeCanvas.getContext('2d');
        const pitchValue = document.getElementById('pitchValue');
        const yawValue = document.getElementById('yawValue');
        const fpsValue = document.getElementById('fpsValue');
        
        function initChart() {
            const ctx = document.getElementById('gazeChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Pitch (Â°)',
                            data: [],
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            tension: 0.4,
                            fill: true
                        },
                        {
                            label: 'Yaw (Â°)',
                            data: [],
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            tension: 0.4,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        y: {
                            min: -45,
                            max: 45,
                            title: {
                                display: true,
                                text: 'è§’åº¦ (Â°)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'æ—¶é—´'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }
        
        function updateStatus(message, type = 'info') {
            statusDiv.className = `status ${type}`;
            statusDiv.innerHTML = type === 'info' && message.includes('åˆå§‹åŒ–') 
                ? `<div class="loading"><div class="spinner"></div><p>${message}</p></div>`
                : `<p>${message}</p>`;
        }
        
        // MediaPipe å…³é”®ç‚¹ç´¢å¼•
        const LEFT_EYE_OUTER = 263;
        const LEFT_EYE_INNER = 362;
        const LEFT_EYE_UPPER = 386;
        const RIGHT_EYE_OUTER = 33;
        const RIGHT_EYE_INNER = 133;
        const RIGHT_EYE_UPPER = 159;
        
        async function initialize() {
            try {
                // åªåŠ è½½æ¨¡å‹ï¼Œä¸åŠ è½½ MediaPipeï¼ˆæ‡’åŠ è½½ä¼˜åŒ–ï¼‰
                updateStatus('â³ æ­£åœ¨åŠ è½½ SwinUNet æ¨¡å‹...', 'info');
                console.log('[Demo] Loading ONNX model...');
                console.log('[Demo] ONNX Runtime version:', ort.env.versions.web);
                console.log('[Demo] WASM paths:', ort.env.wasm.wasmPaths);
                console.log('[Demo] Num threads:', ort.env.wasm.numThreads);
                
                const startTime = Date.now();
                
                session = await ort.InferenceSession.create('../models/swinunet_web.onnx', {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all'
                });
                
                const loadTime = ((Date.now() - startTime) / 1000).toFixed(1);
                console.log(`[Demo] Model loaded in ${loadTime}s`);
                
                updateStatus(`âœ“ æ¨¡å‹åŠ è½½å®Œæˆ (${loadTime}s)ï¼è¯·é€‰æ‹©è§†é¢‘æ–‡ä»¶`, 'success');
                videoInput.disabled = false;
                
            } catch (error) {
                console.error('Initialization error:', error);
                
                // å¤„ç†é”™è¯¯ï¼ˆå¯èƒ½æ˜¯æ•°å­—é”™è¯¯ç æˆ– Error å¯¹è±¡ï¼‰
                const errorMsg = error.message || String(error);
                const errorCode = typeof error === 'number' ? error : null;
                
                if (errorCode === 9403992) {
                    updateStatus(
                        `âŒ ONNX Runtime åˆå§‹åŒ–å¤±è´¥<br><br>` +
                        `é”™è¯¯ç : ${errorCode}<br>` +
                        `å¯èƒ½åŸå› ï¼šWASM æ–‡ä»¶æœªæ‰¾åˆ°<br><br>` +
                        `è¯·è¿è¡Œä»¥ä¸‹å‘½ä»¤ä¸‹è½½ä¾èµ–ï¼š<br>` +
                        `<code style="background:#333;color:#fff;padding:10px;display:block;margin:10px 0;border-radius:4px;">` +
                        `python download_dependencies.py` +
                        `</code>` +
                        `ç„¶ååˆ·æ–°é¡µé¢`,
                        'error'
                    );
                } else if (errorMsg.includes('404') || errorMsg.includes('swinunet.onnx')) {
                    updateStatus(
                        `âŒ æ¨¡å‹æ–‡ä»¶æœªæ‰¾åˆ°<br><br>` +
                        `è¯·å…ˆå¯¼å‡ºæ¨¡å‹ï¼š<br>` +
                        `<code style="background:#333;color:#fff;padding:10px;display:block;margin:10px 0;border-radius:4px;">` +
                        `python export_to_onnx.py --checkpoint checkpoints/checkpoint_best.pth` +
                        `</code>` +
                        `ç„¶ååˆ·æ–°é¡µé¢`,
                        'error'
                    );
                } else {
                    updateStatus(`âŒ åˆå§‹åŒ–å¤±è´¥: ${errorMsg}`, 'error');
                }
            }
        }
        
        async function initMediaPipe() {
            if (faceMesh) return; // å·²åˆå§‹åŒ–
            
            updateStatus('â³ é¦–æ¬¡è¿è¡Œéœ€è¦åˆå§‹åŒ–äººè„¸æ£€æµ‹ (çº¦ 2-3 ç§’)...', 'info');
            console.log('[Demo] Initializing MediaPipe...');
            const startTime = Date.now();
            
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    // ä½¿ç”¨æœ¬åœ°æ–‡ä»¶ï¼Œæ— éœ€è®¿é—® CDN
                    return `lib/${file}`;
                }
            });
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            // ç­‰å¾… MediaPipe å®Œå…¨åˆå§‹åŒ–
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const loadTime = ((Date.now() - startTime) / 1000).toFixed(1);
            console.log(`[Demo] MediaPipe initialized in ${loadTime}s`);
        }
        
        videoInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                videoFile = file;
                const url = URL.createObjectURL(file);
                videoElement.src = url;
                video = videoElement;
                
                fileLabel.textContent = `âœ“ ${file.name}`;
                startBtn.disabled = false;
                updateStatus(`âœ“ è§†é¢‘å·²åŠ è½½: ${file.name}`, 'success');
            }
        });
        
        async function startProcessing() {
            if (!video) return;
            
            // æ‡’åŠ è½½ MediaPipe
            if (!faceMesh) {
                try {
                    await initMediaPipe();
                } catch (error) {
                    updateStatus(`âŒ MediaPipe åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
                    return;
                }
            }
            
            video.currentTime = 0;
            video.play();
            
            isRunning = true;
            startBtn.disabled = true;
            stopBtn.disabled = false;
            videoInput.disabled = true;
            
            updateStatus('âœ“ æ­£åœ¨å¤„ç†è§†é¢‘...', 'success');
            
            processFrames();
        }
        
        function stopProcessing() {
            isRunning = false;
            
            if (video) {
                video.pause();
            }
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
            videoInput.disabled = false;
            
            updateStatus('å¤„ç†å·²åœæ­¢', 'info');
        }
        
        async function extractEyeROI(source, eye) {
            // ä½¿ç”¨ MediaPipe æ£€æµ‹äººè„¸å…³é”®ç‚¹
            console.log('[ExtractROI] Sending image to MediaPipe...');
            
            // MediaPipe ä½¿ç”¨å›è°ƒæ¨¡å¼ï¼Œéœ€è¦åŒ…è£…æˆ Promise
            const results = await new Promise((resolve) => {
                faceMesh.onResults((r) => {
                    resolve(r);
                });
                faceMesh.send({ image: source });
            });
            
            console.log('[ExtractROI] MediaPipe results:', results);
            
            if (!results || !results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
                console.warn('[ExtractROI] No face landmarks detected');
                return null;
            }
            
            console.log('[ExtractROI] Face detected, landmarks count:', results.multiFaceLandmarks[0].length);
            const landmarks = results.multiFaceLandmarks[0];
            
            // è·å–çœ¼éƒ¨å…³é”®ç‚¹
            let outerIdx, innerIdx, upperIdx;
            if (eye === 'right') {
                outerIdx = RIGHT_EYE_OUTER;
                innerIdx = RIGHT_EYE_INNER;
                upperIdx = RIGHT_EYE_UPPER;
            } else {
                outerIdx = LEFT_EYE_OUTER;
                innerIdx = LEFT_EYE_INNER;
                upperIdx = LEFT_EYE_UPPER;
            }
            
            const width = source.videoWidth || source.width;
            const height = source.videoHeight || source.height;
            
            // è½¬æ¢ä¸ºåƒç´ åæ ‡
            const outer = landmarks[outerIdx];
            const inner = landmarks[innerIdx];
            const upper = landmarks[upperIdx];
            
            const outerX = outer.x * width;
            const outerY = outer.y * height;
            const innerX = inner.x * width;
            const innerY = inner.y * height;
            const upperX = upper.x * width;
            const upperY = upper.y * height;
            
            // è®¡ç®—çœ¼éƒ¨è¾¹ç•Œæ¡†
            const minX = Math.min(outerX, innerX, upperX);
            const maxX = Math.max(outerX, innerX, upperX);
            const minY = Math.min(outerY, innerY, upperY);
            const maxY = Math.max(outerY, innerY, upperY);
            
            const boxWidth = maxX - minX;
            const boxHeight = maxY - minY;
            
            // æ·»åŠ  padding
            const pad = 0.5;
            const x1 = Math.max(0, minX - boxWidth * pad);
            const y1 = Math.max(0, minY - boxHeight * pad);
            const x2 = Math.min(width, maxX + boxWidth * pad);
            const y2 = Math.min(height, maxY + boxHeight * pad);
            
            // è£å‰ªçœ¼éƒ¨åŒºåŸŸ
            const canvas = document.createElement('canvas');
            canvas.width = 60;
            canvas.height = 36;
            const ctx = canvas.getContext('2d');
            
            ctx.drawImage(
                source,
                x1, y1, x2 - x1, y2 - y1,
                0, 0, 60, 36
            );
            
            // è½¬æ¢ä¸ºå¼ é‡ (1, 3, 36, 60)
            const imageData = ctx.getImageData(0, 0, 60, 36);
            const pixels = imageData.data;
            
            const inputData = new Float32Array(1 * 3 * 36 * 60);
            
            // è½¬æ¢ä¸º NCHW æ ¼å¼å¹¶å½’ä¸€åŒ–
            for (let h = 0; h < 36; h++) {
                for (let w = 0; w < 60; w++) {
                    const idx = (h * 60 + w) * 4;
                    const r = pixels[idx] / 255.0;
                    const g = pixels[idx + 1] / 255.0;
                    const b = pixels[idx + 2] / 255.0;
                    
                    inputData[0 * 36 * 60 + h * 60 + w] = r;
                    inputData[1 * 36 * 60 + h * 60 + w] = g;
                    inputData[2 * 36 * 60 + h * 60 + w] = b;
                }
            }
            
            return { inputData, canvas };
        }
        
        function vectorToAngles(vector) {
            const [x, y, z] = vector;
            const pitch = Math.asin(-y) * 180 / Math.PI;
            const yaw = Math.atan2(-x, -z) * 180 / Math.PI;
            return { pitch, yaw };
        }
        
        async function processFrames() {
            if (!isRunning || video.paused || video.ended) {
                if (video.ended) {
                    updateStatus('âœ“ è§†é¢‘å¤„ç†å®Œæˆ', 'success');
                    stopProcessing();
                }
                return;
            }
            
            try {
                const eye = eyeSelect.value;
                
                // æå–çœ¼éƒ¨ ROI
                console.log('[Process] Extracting eye ROI for:', eye);
                const roiData = await extractEyeROI(video, eye);
                
                if (!roiData) {
                    console.warn('[Process] No face detected in current frame');
                    // æ˜¾ç¤º"æœªæ£€æµ‹åˆ°äººè„¸"
                    eyeCtx.fillStyle = '#333';
                    eyeCtx.fillRect(0, 0, eyeCanvas.width, eyeCanvas.height);
                    eyeCtx.fillStyle = '#fff';
                    eyeCtx.font = '14px Arial';
                    eyeCtx.textAlign = 'center';
                    eyeCtx.fillText('æœªæ£€æµ‹åˆ°äººè„¸', eyeCanvas.width/2, eyeCanvas.height/2);
                } else {
                    console.log('[Process] ROI extracted successfully');
                    
                    // æ˜¾ç¤ºçœ¼éƒ¨ ROI
                    eyeCtx.drawImage(roiData.canvas, 0, 0, eyeCanvas.width, eyeCanvas.height);
                    
                    // ONNX æ¨ç†
                    console.log('[Process] Running inference...');
                    const inputTensor = new ort.Tensor('float32', roiData.inputData, [1, 3, 36, 60]);
                    const results = await session.run({ input: inputTensor });
                    const output = results.output.data;
                    
                    console.log('[Process] Raw output:', output[0], output[1], output[2]);
                    
                    // å½’ä¸€åŒ–ä¸ºå•ä½å‘é‡
                    const norm = Math.sqrt(output[0]**2 + output[1]**2 + output[2]**2);
                    const vector = [output[0]/norm, output[1]/norm, output[2]/norm];
                    
                    // è½¬æ¢ä¸ºè§’åº¦
                    const angles = vectorToAngles(vector);
                    console.log('[Process] Angles - Pitch:', angles.pitch.toFixed(1), 'Yaw:', angles.yaw.toFixed(1));
                    
                    pitchValue.textContent = angles.pitch.toFixed(1) + 'Â°';
                    yawValue.textContent = angles.yaw.toFixed(1) + 'Â°';
                    
                    updateChart(angles);
                }
                
                frameCount++;
                const now = Date.now();
                if (now - lastTime >= 1000) {
                    fpsValue.textContent = frameCount;
                    frameCount = 0;
                    lastTime = now;
                }
                
            } catch (error) {
                console.error('[Process] ERROR:', error);
                console.error('[Process] Error stack:', error.stack);
                updateStatus('âŒ å¤„ç†é”™è¯¯: ' + error.message, 'error');
            }
            
            requestAnimationFrame(processFrames);
        }
        
        function drawEyeROI() {
            eyeCtx.drawImage(video, 0, 0, eyeCanvas.width, eyeCanvas.height);
        }
        
        function updateChart(gaze) {
            const now = new Date().toLocaleTimeString();
            
            chart.data.labels.push(now);
            chart.data.datasets[0].data.push(gaze.pitch);
            chart.data.datasets[1].data.push(gaze.yaw);
            
            if (chart.data.labels.length > 50) {
                chart.data.labels.shift();
                chart.data.datasets[0].data.shift();
                chart.data.datasets[1].data.shift();
            }
            
            chart.update('none');
        }
        
        function clearHistory() {
            chart.data.labels = [];
            chart.data.datasets[0].data = [];
            chart.data.datasets[1].data = [];
            chart.update();
            
            pitchValue.textContent = '--';
            yawValue.textContent = '--';
        }
        
        startBtn.addEventListener('click', startProcessing);
        stopBtn.addEventListener('click', stopProcessing);
        clearBtn.addEventListener('click', clearHistory);
        
        // é…ç½® ONNX Runtime ä½¿ç”¨æœ¬åœ° WASM æ–‡ä»¶ï¼ˆå¿…é¡»åœ¨åŠ è½½æ¨¡å‹å‰è®¾ç½®ï¼‰
        // ä½¿ç”¨ç®€å•çš„å•çº¿ç¨‹æ¨¡å¼ï¼Œé¿å… SharedArrayBuffer é—®é¢˜
        ort.env.wasm.numThreads = 1;  // å¼ºåˆ¶å•çº¿ç¨‹
        ort.env.wasm.simd = true;      // å¯ç”¨ SIMDï¼ˆå¦‚æœæ”¯æŒï¼‰
        ort.env.wasm.wasmPaths = 'lib/';  // ä½¿ç”¨ç›®å½•è·¯å¾„
        
        console.log('[Demo] ONNX Runtime WASM configuration:');
        console.log('  - numThreads:', ort.env.wasm.numThreads);
        console.log('  - simd:', ort.env.wasm.simd);
        console.log('  - wasmPaths:', ort.env.wasm.wasmPaths);
        
        window.addEventListener('load', () => {
            initChart();
            initialize();
        });
        
        window.addEventListener('beforeunload', () => {
            stopProcessing();
        });
    </script>
</body>
</html>
